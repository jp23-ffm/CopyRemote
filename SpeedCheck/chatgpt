from django.db.models import Q, Value
from django.db.models.functions import Lower

query_filter = Q()

for field, values in mapped_filters.items():
    if not values:
        continue

    has_wildcards = any('*' in v for v in values)

    if has_wildcards:
        or_conditions = Q()
        for value in values:
            value_pattern = value.replace('*', '.*')
            or_conditions |= Q(**{f"{field}__iregex": f"^{value_pattern}$"})
        query_filter &= or_conditions

    else:
        # ‚úÖ Case-insensitive "IN" via annotation (Postgres)
        lowered_values = [v.lower() for v in values]
        query_filter &= Q(**{f"{field}__in": lowered_values})

# Quand tu construis ton queryset :
queryset = index_cls.objects.annotate(**{
    f"{field}": Lower(field)
}).filter(query_filter)



---------------


lowered_values = [v.lower() for v in values]
query_filter &= Q(**{f"{field}__in": lowered_values})

queryset = index_cls.objects.annotate(**{f"{field}": Lower(field)}).filter(query_filter)


----------------

from django.db.models import Q
from django.db.models.functions import Lower

# Construction du filtre global
query_filter = Q()

# On pr√©pare une annotation "Lower" pour rendre les comparaisons insensibles √† la casse
# Elle est ignor√©e par SQLite si inutilis√©e (pas de souci de compatibilit√©)
lower_annotations = {}

for field, values in mapped_filters.items():
    if not values:
        continue

    has_wildcards = any('*' in v for v in values)

    if has_wildcards:
        # üîç Cas avec wildcard (*) ‚Üí on garde un comportement regex
        or_conditions = Q()
        for value in values:
            # On transforme les jokers en regex
            value_pattern = value.replace('*', '.*')
            # On applique un filtre insensible √† la casse avec iregex
            or_conditions |= Q(**{f"{field}__iregex": f"^{value_pattern}$"})
        query_filter &= or_conditions

    else:
        # ‚úÖ Cas standard (pas de joker)
        # On pr√©pare les valeurs en minuscules pour le __in
        lowered_values = [v.lower() for v in values]

        # On cr√©e une annotation sur le champ lower(field)
        lower_field_name = f"{field}_lower"
        lower_annotations[lower_field_name] = Lower(field)

        # On ajoute le filtre insensible √† la casse
        query_filter &= Q(**{f"{lower_field_name}__in": lowered_values})


# === Application du filtre sur la queryset ===
# On applique les annotations "Lower" si n√©cessaires (case-insensitive PostgreSQL)
if lower_annotations:
    queryset = index_cls.objects.annotate(**lower_annotations).filter(query_filter).distinct()
else:
    queryset = index_cls.objects.filter(query_filter).distinct()


----------------

from django.db.models import Q
from django.db.models.functions import Lower

# On initialise la queryset
queryset = index_cls.objects.all()

# === üöÄ Pr√©filtrage sur SERVER_ID si pr√©sent ===
server_id_field = None
for f in mapped_filters.keys():
    if f.lower() in ("server_id", "srv_id", "id_server"):  # adapte √† ton mapping
        server_id_field = f
        break

if server_id_field and mapped_filters[server_id_field]:
    values = mapped_filters.pop(server_id_field)
    has_wildcards = any('*' in v for v in values)

    if has_wildcards:
        # Wildcards (*)
        or_conditions = Q()
        for value in values:
            pattern = value.replace('*', '.*')
            or_conditions |= Q(**{f"{server_id_field}__iregex": f"^{pattern}$"})
        queryset = queryset.filter(or_conditions)
    else:
        # __in case-insensitive
        lowered_values = [v.lower() for v in values]
        queryset = queryset.annotate(server_id_lower=Lower(server_id_field)).filter(
            server_id_lower__in=lowered_values
        )

    # üí° Si aucun serveur trouv√©, inutile d‚Äôaller plus loin
    if not queryset.exists():
        return Response([], status=status.HTTP_200_OK)


# === ‚öôÔ∏è Construction du filtre global pour les autres champs ===
query_filter = Q()
lower_annotations = {}

for field, values in mapped_filters.items():
    if not values:
        continue

    has_wildcards = any('*' in v for v in values)

    if has_wildcards:
        # üîç Cas avec wildcard
        or_conditions = Q()
        for value in values:
            value_pattern = value.replace('*', '.*')
            or_conditions |= Q(**{f"{field}__iregex": f"^{value_pattern}$"})
        query_filter &= or_conditions

    else:
        # ‚úÖ Cas standard : __in insensible √† la casse
        lowered_values = [v.lower() for v in values]
        lower_field_name = f"{field}_lower"
        lower_annotations[lower_field_name] = Lower(field)
        query_filter &= Q(**{f"{lower_field_name}__in": lowered_values})


# === üîé Application finale des filtres ===
if lower_annotations:
    queryset = queryset.annotate(**lower_annotations).filter(query_filter).distinct()
else:
    queryset = queryset.filter(query_filter).distinct()


---------------------------

pip install orjson

#myapp/parsers.py
from rest_framework.parsers import BaseParser
import orjson

class ORJSONParser(BaseParser):
    """
    Parser JSON bas√© sur orjson ‚Äî plus rapide et sans limite de profondeur.
    """
    media_type = 'application/json'

    def parse(self, stream, media_type=None, parser_context=None):
        data = stream.read()
        if not data:
            return {}
        return orjson.loads(data)




REST_FRAMEWORK = {
    "DEFAULT_PARSER_CLASSES": [
        "myapp.parsers.ORJSONParser",
    ],
}


---------------------------


#myapp/parsers.py
from rest_framework.renderers import JSONRenderer
import orjson

class ORJSONRenderer(JSONRenderer):
    """
    Renderer JSON bas√© sur orjson.
    """
    def render(self, data, accepted_media_type=None, renderer_context=None):
        return orjson.dumps(data)



REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": [
        "myapp.renderers.ORJSONRenderer",
    ],
    "DEFAULT_PARSER_CLASSES": [
        "myapp.parsers.ORJSONParser",
    ],
}
