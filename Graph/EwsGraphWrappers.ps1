#Requires -Modules Microsoft.Graph.Mail, Microsoft.Graph.Users

<#
.SYNOPSIS
    Bibliothèque de wrappers pour migrer EWS vers Microsoft Graph
    
.DESCRIPTION
    Ces fonctions imitent le comportement des objets EWS pour minimiser
    les changements dans les scripts existants lors de la migration vers Graph.
    
.NOTES
    Prérequis: Connect-MgGraph doit être appelé avant d'utiliser ces fonctions
    Permissions nécessaires: Mail.ReadWrite, Mail.ReadWrite.Shared (si délégation)
#>

# Variable globale pour stocker l'utilisateur en cours (pour impersonation)
$script:EwsCompat_CurrentUser = $null

#region Configuration et Connexion

<#
.SYNOPSIS
    Initialise la connexion Graph en mode "impersonation"
    
.DESCRIPTION
    Remplace la création du ExchangeService EWS avec impersonation.
    Configure l'utilisateur cible pour toutes les opérations suivantes.
    
.PARAMETER UserEmail
    Adresse email de la boîte aux lettres à consulter
    
.EXAMPLE
    Initialize-EwsCompatConnection -UserEmail "user@domain.com"
#>
function Initialize-EwsCompatConnection {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$UserEmail
    )
    
    try {
        # Vérifier que Graph est connecté
        $context = Get-MgContext
        if (-not $context) {
            throw "Microsoft Graph n'est pas connecté. Utilisez Connect-MgGraph d'abord."
        }
        
        # Stocker l'utilisateur pour les opérations futures
        $script:EwsCompat_CurrentUser = $UserEmail
        
        Write-Verbose "Connexion Graph initialisée pour: $UserEmail"
        
        return [PSCustomObject]@{
            Success = $true
            User = $UserEmail
            Context = $context
        }
    }
    catch {
        Write-Error "Erreur lors de l'initialisation: $_"
        return [PSCustomObject]@{
            Success = $false
            Error = $_.Exception.Message
        }
    }
}

#endregion

#region Gestion des Dossiers

<#
.SYNOPSIS
    Récupère un dossier par son nom (équivalent FindFolders)
    
.DESCRIPTION
    Simule ExchangeService.FindFolders() en recherchant un dossier par nom
    
.PARAMETER ParentFolderId
    ID du dossier parent (ou "Inbox" pour la boîte de réception)
    
.PARAMETER DisplayName
    Nom du dossier à rechercher
    
.EXAMPLE
    $folder = Get-EwsCompatFolder -ParentFolderId "Inbox" -DisplayName "TODO"
#>
function Get-EwsCompatFolder {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ParentFolderId,
        
        [Parameter(Mandatory = $false)]
        [string]$DisplayName
    )
    
    if (-not $script:EwsCompat_CurrentUser) {
        throw "Utilisateur non initialisé. Appelez Initialize-EwsCompatConnection d'abord."
    }
    
    try {
        # Gérer le cas spécial "Inbox"
        if ($ParentFolderId -eq "Inbox") {
            $ParentFolderId = "Inbox"
        }
        
        # Récupérer les sous-dossiers
        $folders = Get-MgUserMailFolderChildFolder -UserId $script:EwsCompat_CurrentUser -MailFolderId $ParentFolderId
        
        # Filtrer par nom si spécifié
        if ($DisplayName) {
            $folders = $folders | Where-Object { $_.DisplayName -eq $DisplayName }
        }
        
        # Convertir en objets compatibles EWS
        $compatFolders = @()
        foreach ($folder in $folders) {
            $compatFolders += New-EwsCompatFolder -GraphFolder $folder
        }
        
        return $compatFolders
    }
    catch {
        Write-Error "Erreur lors de la récupération des dossiers: $_"
        return $null
    }
}

<#
.SYNOPSIS
    Crée un objet dossier compatible EWS
    
.DESCRIPTION
    Fonction interne pour convertir un dossier Graph en objet compatible EWS
#>
function New-EwsCompatFolder {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $GraphFolder
    )
    
    $obj = [PSCustomObject]@{
        Id = $GraphFolder.Id
        DisplayName = $GraphFolder.DisplayName
        TotalCount = $GraphFolder.TotalItemCount
        UnreadCount = $GraphFolder.UnreadItemCount
        ChildFolderCount = $GraphFolder.ChildFolderCount
    }
    
    # Ajouter un type pour faciliter l'identification
    $obj.PSObject.TypeNames.Insert(0, 'EwsCompat.Folder')
    
    return $obj
}

#endregion

#region Gestion des Messages

<#
.SYNOPSIS
    Récupère les messages d'un dossier (équivalent FindItems)
    
.DESCRIPTION
    Simule FolderObject.FindItems() avec support du tri et de la pagination
    
.PARAMETER FolderId
    ID du dossier ou objet dossier compatible EWS
    
.PARAMETER Top
    Nombre de messages à récupérer (défaut: 1)
    
.PARAMETER OrderBy
    Champ de tri: "DateTimeReceived" ou "Subject"
    
.PARAMETER Ascending
    Ordre croissant (true) ou décroissant (false)
    
.EXAMPLE
    $messages = Get-EwsCompatMessages -FolderId $folder.Id -Top 1 -OrderBy "DateTimeReceived" -Ascending $true
#>
function Get-EwsCompatMessages {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $FolderId,
        
        [Parameter(Mandatory = $false)]
        [int]$Top = 1,
        
        [Parameter(Mandatory = $false)]
        [ValidateSet("DateTimeReceived", "Subject", "From")]
        [string]$OrderBy = "DateTimeReceived",
        
        [Parameter(Mandatory = $false)]
        [bool]$Ascending = $true
    )
    
    if (-not $script:EwsCompat_CurrentUser) {
        throw "Utilisateur non initialisé. Appelez Initialize-EwsCompatConnection d'abord."
    }
    
    try {
        # Extraire l'ID si c'est un objet
        if ($FolderId -is [PSCustomObject] -and $FolderId.Id) {
            $FolderId = $FolderId.Id
        }
        
        # Récupérer les messages
        $messages = Get-MgUserMailFolderMessage -UserId $script:EwsCompat_CurrentUser -MailFolderId $FolderId -Top $Top -All:$false
        
        # Trier les messages (Graph ne supporte pas toujours l'orderby via API)
        switch ($OrderBy) {
            "DateTimeReceived" {
                if ($Ascending) {
                    $messages = $messages | Sort-Object ReceivedDateTime
                } else {
                    $messages = $messages | Sort-Object ReceivedDateTime -Descending
                }
            }
            "Subject" {
                if ($Ascending) {
                    $messages = $messages | Sort-Object Subject
                } else {
                    $messages = $messages | Sort-Object Subject -Descending
                }
            }
        }
        
        # Prendre seulement le Top demandé après tri
        $messages = $messages | Select-Object -First $Top
        
        # Convertir en objets compatibles EWS
        $compatMessages = @()
        foreach ($message in $messages) {
            # Récupérer les pièces jointes pour ce message
            $attachments = Get-MgUserMessageAttachment -UserId $script:EwsCompat_CurrentUser -MessageId $message.Id -ErrorAction SilentlyContinue
            
            $compatMessages += New-EwsCompatMessage -GraphMessage $message -GraphAttachments $attachments
        }
        
        # Créer un objet collection compatible avec .Load()
        $collection = [PSCustomObject]@{
            Items = $compatMessages
            Count = $compatMessages.Count
        }
        
        # Ajouter une méthode Load() factice (pour compatibilité)
        $collection | Add-Member -MemberType ScriptMethod -Name "Load" -Value {
            # Déjà chargé, ne fait rien
            Write-Verbose "Load() appelé - données déjà chargées avec Graph"
        }
        
        return $collection
    }
    catch {
        Write-Error "Erreur lors de la récupération des messages: $_"
        return $null
    }
}

<#
.SYNOPSIS
    Crée un objet message compatible EWS
    
.DESCRIPTION
    Fonction interne pour convertir un message Graph en objet compatible EWS
#>
function New-EwsCompatMessage {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $GraphMessage,
        
        [Parameter(Mandatory = $false)]
        $GraphAttachments
    )
    
    # Convertir les pièces jointes
    $compatAttachments = @()
    if ($GraphAttachments) {
        foreach ($att in $GraphAttachments) {
            $compatAttachments += New-EwsCompatAttachment -GraphAttachment $att -MessageId $GraphMessage.Id
        }
    }
    
    # Créer l'objet principal
    $obj = [PSCustomObject]@{
        Id = $GraphMessage.Id
        Subject = $GraphMessage.Subject
        DateTimeReceived = $GraphMessage.ReceivedDateTime
        IsRead = $GraphMessage.IsRead
        HasAttachments = $GraphMessage.HasAttachments
        Body = $GraphMessage.Body.Content
        BodyType = $GraphMessage.Body.ContentType
        Attachments = $compatAttachments
        
        # Propriété From compatible EWS
        From = [PSCustomObject]@{
            Address = $GraphMessage.From.EmailAddress.Address
            Name = $GraphMessage.From.EmailAddress.Name
        }
        
        # Pour compatibilité avec .items.Move()
        Items = [PSCustomObject]@{
            _graphId = $GraphMessage.Id
            _graphUser = $script:EwsCompat_CurrentUser
        }
    }
    
    # Ajouter la méthode Move
    $obj.Items | Add-Member -MemberType ScriptMethod -Name "Move" -Value {
        param($DestinationFolderId)
        
        # Extraire l'ID si c'est un objet
        if ($DestinationFolderId -is [PSCustomObject] -and $DestinationFolderId.Id) {
            $DestinationFolderId = $DestinationFolderId.Id
        }
        
        try {
            Move-MgUserMessage -UserId $this._graphUser -MessageId $this._graphId -DestinationId $DestinationFolderId
            Write-Verbose "Message $($this._graphId) déplacé vers $DestinationFolderId"
        }
        catch {
            Write-Error "Erreur lors du déplacement du message: $_"
        }
    }
    
    # Ajouter une méthode Load() factice pour les attachments
    $obj | Add-Member -MemberType ScriptMethod -Name "Load" -Value {
        Write-Verbose "Load() appelé sur le message - données déjà chargées"
    }
    
    $obj.PSObject.TypeNames.Insert(0, 'EwsCompat.Message')
    
    return $obj
}

#endregion

#region Gestion des Pièces Jointes

<#
.SYNOPSIS
    Crée un objet pièce jointe compatible EWS
    
.DESCRIPTION
    Fonction interne pour convertir une pièce jointe Graph en objet compatible EWS
#>
function New-EwsCompatAttachment {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $GraphAttachment,
        
        [Parameter(Mandatory = $true)]
        [string]$MessageId
    )
    
    $obj = [PSCustomObject]@{
        Id = $GraphAttachment.Id
        Name = $GraphAttachment.Name
        ContentType = $GraphAttachment.ContentType
        Size = $GraphAttachment.Size
        IsInline = $GraphAttachment.IsInline
        _messageId = $MessageId
        _graphUser = $script:EwsCompat_CurrentUser
    }
    
    # Ajouter une méthode pour sauvegarder la pièce jointe
    $obj | Add-Member -MemberType ScriptMethod -Name "Load" -Value {
        try {
            # Récupérer le contenu complet de la pièce jointe
            $fullAttachment = Get-MgUserMessageAttachment -UserId $this._graphUser -MessageId $this._messageId -AttachmentId $this.Id
            
            # Ajouter la propriété Content si disponible
            if ($fullAttachment.AdditionalProperties.ContainsKey('contentBytes')) {
                $this | Add-Member -MemberType NoteProperty -Name "ContentBytes" -Value $fullAttachment.AdditionalProperties['contentBytes'] -Force
            }
            
            Write-Verbose "Contenu de la pièce jointe chargé: $($this.Name)"
        }
        catch {
            Write-Error "Erreur lors du chargement de la pièce jointe: $_"
        }
    }
    
    # Méthode pour sauvegarder sur disque (simulant le comportement EWS)
    $obj | Add-Member -MemberType ScriptMethod -Name "SaveToFile" -Value {
        param([string]$Path)
        
        try {
            # Charger le contenu si pas déjà fait
            if (-not $this.ContentBytes) {
                $this.Load()
            }
            
            # Sauvegarder le fichier
            $bytes = [System.Convert]::FromBase64String($this.ContentBytes)
            [System.IO.File]::WriteAllBytes($Path, $bytes)
            
            Write-Verbose "Pièce jointe sauvegardée: $Path"
        }
        catch {
            Write-Error "Erreur lors de la sauvegarde de la pièce jointe: $_"
        }
    }
    
    $obj.PSObject.TypeNames.Insert(0, 'EwsCompat.Attachment')
    
    return $obj
}

<#
.SYNOPSIS
    Sauvegarde toutes les pièces jointes d'un message
    
.PARAMETER Message
    Objet message compatible EWS
    
.PARAMETER DestinationPath
    Chemin de destination pour les pièces jointes
    
.EXAMPLE
    Save-EwsCompatAttachments -Message $message -DestinationPath "C:\Temp\"
#>
function Save-EwsCompatAttachments {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $Message,
        
        [Parameter(Mandatory = $true)]
        [string]$DestinationPath
    )
    
    try {
        # Créer le répertoire si nécessaire
        if (-not (Test-Path $DestinationPath)) {
            New-Item -ItemType Directory -Path $DestinationPath -Force | Out-Null
        }
        
        $savedFiles = @()
        
        foreach ($attachment in $Message.Attachments) {
            $filePath = Join-Path $DestinationPath $attachment.Name
            
            # Charger et sauvegarder
            $attachment.Load()
            $attachment.SaveToFile($filePath)
            
            $savedFiles += $filePath
        }
        
        return $savedFiles
    }
    catch {
        Write-Error "Erreur lors de la sauvegarde des pièces jointes: $_"
        return @()
    }
}

#endregion

#region Fonctions Utilitaires

<#
.SYNOPSIS
    Obtient le nombre de messages dans un dossier
    
.PARAMETER FolderId
    ID du dossier ou objet dossier compatible EWS
    
.EXAMPLE
    $count = Get-EwsCompatFolderMessageCount -FolderId $folder.Id
#>
function Get-EwsCompatFolderMessageCount {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $FolderId
    )
    
    try {
        # Extraire l'ID si c'est un objet
        if ($FolderId -is [PSCustomObject] -and $FolderId.Id) {
            return $FolderId.TotalCount
        }
        
        # Sinon récupérer le dossier
        $folder = Get-MgUserMailFolder -UserId $script:EwsCompat_CurrentUser -MailFolderId $FolderId
        return $folder.TotalItemCount
    }
    catch {
        Write-Error "Erreur lors de la récupération du nombre de messages: $_"
        return 0
    }
}

#endregion

# Export des fonctions
Export-ModuleMember -Function @(
    'Initialize-EwsCompatConnection',
    'Get-EwsCompatFolder',
    'Get-EwsCompatMessages',
    'Save-EwsCompatAttachments',
    'Get-EwsCompatFolderMessageCount'
)