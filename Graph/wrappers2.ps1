#Requires -Modules Microsoft.Graph.Mail, Microsoft.Graph.Users

<#
.SYNOPSIS
    Bibliothèque de wrappers pour migrer EWS vers Microsoft Graph
    
.DESCRIPTION
    Ces fonctions imitent le comportement des objets EWS pour minimiser
    les changements dans les scripts existants lors de la migration vers Graph.
    
.NOTES
    Prérequis: Connect-MgGraph doit être appelé avant d'utiliser ces fonctions
    Permissions nécessaires: Mail.ReadWrite, Mail.ReadWrite.Shared (si délégation)
#>

# Variable globale pour stocker l'utilisateur en cours (pour impersonation)
$script:EwsCompat_CurrentUser = $null

#region Configuration et Connexion

<#
.SYNOPSIS
    Initialise la connexion Graph en mode "impersonation"
    
.DESCRIPTION
    Remplace la création du ExchangeService EWS avec impersonation.
    Configure l'utilisateur cible pour toutes les opérations suivantes.
    
.PARAMETER UserEmail
    Adresse email de la boîte aux lettres à consulter
    
.EXAMPLE
    Initialize-EwsCompatConnection -UserEmail "user@domain.com"
#>
function Initialize-EwsCompatConnection {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$UserEmail
    )
    
    try {
        # Vérifier que Graph est connecté
        $context = Get-MgContext
        if (-not $context) {
            throw "Microsoft Graph n'est pas connecté. Utilisez Connect-MgGraph d'abord."
        }
        
        # Stocker l'utilisateur pour les opérations futures
        $script:EwsCompat_CurrentUser = $UserEmail
        
        Write-Verbose "Connexion Graph initialisée pour: $UserEmail"
        
        return [PSCustomObject]@{
            Success = $true
            User = $UserEmail
            Context = $context
        }
    }
    catch {
        Write-Error "Erreur lors de l'initialisation: $_"
        return [PSCustomObject]@{
            Success = $false
            Error = $_.Exception.Message
        }
    }
}

#endregion

#region Gestion des Dossiers

<#
.SYNOPSIS
    Récupère un dossier par son nom (équivalent FindFolders)
    
.DESCRIPTION
    Simule ExchangeService.FindFolders() en recherchant un dossier par nom
    
.PARAMETER ParentFolderId
    ID du dossier parent (ou "Inbox" pour la boîte de réception)
    
.PARAMETER DisplayName
    Nom du dossier à rechercher
    
.EXAMPLE
    $folder = Get-EwsCompatFolder -ParentFolderId "Inbox" -DisplayName "TODO"
#>
function Get-EwsCompatFolder {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ParentFolderId,
        
        [Parameter(Mandatory = $false)]
        [string]$DisplayName
    )
    
    if (-not $script:EwsCompat_CurrentUser) {
        throw "Utilisateur non initialisé. Appelez Initialize-EwsCompatConnection d'abord."
    }
    
    try {
        # Gérer le cas spécial "Inbox" - on doit d'abord récupérer le dossier Inbox pour avoir son ID
        if ($ParentFolderId -eq "Inbox") {
            Write-Verbose "Récupération du dossier Inbox"
            $inboxFolder = Get-MgUserMailFolder -UserId $script:EwsCompat_CurrentUser -MailFolderId "Inbox"
            $ParentFolderId = $inboxFolder.Id
        }
        
        # Récupérer les sous-dossiers
        $folders = Get-MgUserMailFolderChildFolder -UserId $script:EwsCompat_CurrentUser -MailFolderId $ParentFolderId
        
        # Filtrer par nom si spécifié
        if ($DisplayName) {
            $folders = $folders | Where-Object { $_.DisplayName -eq $DisplayName }
        }
        
        # Convertir en objets compatibles EWS
        $compatFolders = @()
        foreach ($folder in $folders) {
            $compatFolders += New-EwsCompatFolder -GraphFolder $folder
        }
        
        return $compatFolders
    }
    catch {
        Write-Error "Erreur lors de la récupération des dossiers: $_"
        Write-Verbose "Détails: $($_.Exception.Message)"
        return $null
    }
}

<#
.SYNOPSIS
    Crée un objet dossier compatible EWS
    
.DESCRIPTION
    Fonction interne pour convertir un dossier Graph en objet compatible EWS
#>
function New-EwsCompatFolder {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $GraphFolder
    )
    
    $obj = [PSCustomObject]@{
        Id = $GraphFolder.Id
        DisplayName = $GraphFolder.DisplayName
        TotalCount = $GraphFolder.TotalItemCount
        UnreadCount = $GraphFolder.UnreadItemCount
        ChildFolderCount = $GraphFolder.ChildFolderCount
    }
    
    # Ajouter un type pour faciliter l'identification
    $obj.PSObject.TypeNames.Insert(0, 'EwsCompat.Folder')
    
    return $obj
}

#endregion

#region Gestion des Messages

<#
.SYNOPSIS
    Récupère les messages d'un dossier (équivalent FindItems)
    
.DESCRIPTION
    Simule FolderObject.FindItems() avec support du tri et de la pagination
    
.PARAMETER FolderId
    ID du dossier ou objet dossier compatible EWS
    
.PARAMETER Top
    Nombre de messages à récupérer (défaut: 1)
    
.PARAMETER OrderBy
    Champ de tri: "DateTimeReceived" ou "Subject"
    
.PARAMETER Ascending
    Ordre croissant (true) ou décroissant (false)
    
.EXAMPLE
    $messages = Get-EwsCompatMessages -FolderId $folder.Id -Top 1 -OrderBy "DateTimeReceived" -Ascending $true
#>
function Get-EwsCompatMessages {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $FolderId,
        
        [Parameter(Mandatory = $false)]
        [int]$Top = 1,
        
        [Parameter(Mandatory = $false)]
        [ValidateSet("DateTimeReceived", "Subject", "From")]
        [string]$OrderBy = "DateTimeReceived",
        
        [Parameter(Mandatory = $false)]
        [bool]$Ascending = $true
    )
    
    if (-not $script:EwsCompat_CurrentUser) {
        throw "Utilisateur non initialisé. Appelez Initialize-EwsCompatConnection d'abord."
    }
    
    try {
        # Extraire l'ID si c'est un objet
        if ($FolderId -is [PSCustomObject] -and $FolderId.Id) {
            $FolderId = $FolderId.Id
        }
        
        # Récupérer les messages
        $messages = Get-MgUserMailFolderMessage -UserId $script:EwsCompat_CurrentUser -MailFolderId $FolderId -Top $Top -All:$false
        
        # Trier les messages (Graph ne supporte pas toujours l'orderby via API)
        switch ($OrderBy) {
            "DateTimeReceived" {
                if ($Ascending) {
                    $messages = $messages | Sort-Object ReceivedDateTime
                } else {
                    $messages = $messages | Sort-Object ReceivedDateTime -Descending
                }
            }
            "Subject" {
                if ($Ascending) {
                    $messages = $messages | Sort-Object Subject
                } else {
                    $messages = $messages | Sort-Object Subject -Descending
                }
            }
        }
        
        # Prendre seulement le Top demandé après tri
        $messages = $messages | Select-Object -First $Top
        
        # Convertir en objets compatibles EWS
        $compatMessages = @()
        foreach ($message in $messages) {
            # Récupérer les pièces jointes pour ce message
            $attachments = Get-MgUserMessageAttachment -UserId $script:EwsCompat_CurrentUser -MessageId $message.Id -ErrorAction SilentlyContinue
            
            $compatMessages += New-EwsCompatMessage -GraphMessage $message -GraphAttachments $attachments
        }
        
        # Créer un objet collection compatible avec .Load()
        $collection = [PSCustomObject]@{
            Items = $compatMessages
            Count = $compatMessages.Count
        }
        
        # Ajouter une méthode Load() factice (pour compatibilité)
        $collection | Add-Member -MemberType ScriptMethod -Name "Load" -Value {
            # Déjà chargé, ne fait rien
            Write-Verbose "Load() appelé - données déjà chargées avec Graph"
        }
        
        return $collection
    }
    catch {
        Write-Error "Erreur lors de la récupération des messages: $_"
        return $null
    }
}

<#
.SYNOPSIS
    Crée un objet message compatible EWS
    
.DESCRIPTION
    Fonction interne pour convertir un message Graph en objet compatible EWS
#>
function New-EwsCompatMessage {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $GraphMessage,
        
        [Parameter(Mandatory = $false)]
        $GraphAttachments
    )
    
    # Convertir les pièces jointes
    $compatAttachments = @()
    if ($GraphAttachments) {
        foreach ($att in $GraphAttachments) {
            $compatAttachments += New-EwsCompatAttachment -GraphAttachment $att -MessageId $GraphMessage.Id
        }
    }
    
    # Créer l'objet principal
    $obj = [PSCustomObject]@{
        Id = $GraphMessage.Id
        Subject = $GraphMessage.Subject
        DateTimeReceived = $GraphMessage.ReceivedDateTime
        IsRead = $GraphMessage.IsRead
        HasAttachments = $GraphMessage.HasAttachments
        Body = $GraphMessage.Body.Content
        BodyType = $GraphMessage.Body.ContentType
        Attachments = $compatAttachments
        
        # Propriété From compatible EWS
        From = [PSCustomObject]@{
            Address = $GraphMessage.From.EmailAddress.Address
            Name = $GraphMessage.From.EmailAddress.Name
        }
        
        # Pour compatibilité avec .items.Move()
        Items = [PSCustomObject]@{
            _graphId = $GraphMessage.Id
            _graphUser = $script:EwsCompat_CurrentUser
        }
    }
    
    # Ajouter la méthode Move
    $obj.Items | Add-Member -MemberType ScriptMethod -Name "Move" -Value {
        param($DestinationFolderId)
        
        # Extraire l'ID si c'est un objet
        if ($DestinationFolderId -is [PSCustomObject] -and $DestinationFolderId.Id) {
            $DestinationFolderId = $DestinationFolderId.Id
        }
        
        try {
            Move-MgUserMessage -UserId $this._graphUser -MessageId $this._graphId -DestinationId $DestinationFolderId
            Write-Verbose "Message $($this._graphId) déplacé vers $DestinationFolderId"
        }
        catch {
            Write-Error "Erreur lors du déplacement du message: $_"
        }
    }
    
    # Ajouter une méthode Load() factice pour les attachments
    $obj | Add-Member -MemberType ScriptMethod -Name "Load" -Value {
        Write-Verbose "Load() appelé sur le message - données déjà chargées"
    }
    
    $obj.PSObject.TypeNames.Insert(0, 'EwsCompat.Message')
    
    return $obj
}

#endregion

#region Gestion des Pièces Jointes

<#
.SYNOPSIS
    Crée un objet pièce jointe compatible EWS
    
.DESCRIPTION
    Fonction interne pour convertir une pièce jointe Graph en objet compatible EWS
#>
function New-EwsCompatAttachment {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $GraphAttachment,
        
        [Parameter(Mandatory = $true)]
        [string]$MessageId
    )
    
    $obj = [PSCustomObject]@{
        Id = $GraphAttachment.Id
        Name = $GraphAttachment.Name
        ContentType = $GraphAttachment.ContentType
        Size = $GraphAttachment.Size
        IsInline = $GraphAttachment.IsInline
        _messageId = $MessageId
        _graphUser = $script:EwsCompat_CurrentUser
    }
    
    # Ajouter une méthode pour sauvegarder la pièce jointe
    $obj | Add-Member -MemberType ScriptMethod -Name "Load" -Value {
        try {
            # Récupérer le contenu complet de la pièce jointe
            $fullAttachment = Get-MgUserMessageAttachment -UserId $this._graphUser -MessageId $this._messageId -AttachmentId $this.Id
            
            # Ajouter la propriété Content si disponible
            if ($fullAttachment.AdditionalProperties.ContainsKey('contentBytes')) {
                $this | Add-Member -MemberType NoteProperty -Name "ContentBytes" -Value $fullAttachment.AdditionalProperties['contentBytes'] -Force
            }
            
            Write-Verbose "Contenu de la pièce jointe chargé: $($this.Name)"
        }
        catch {
            Write-Error "Erreur lors du chargement de la pièce jointe: $_"
        }
    }
    
    # Méthode pour sauvegarder sur disque (simulant le comportement EWS)
    $obj | Add-Member -MemberType ScriptMethod -Name "SaveToFile" -Value {
        param([string]$Path)
        
        try {
            # Charger le contenu si pas déjà fait
            if (-not $this.ContentBytes) {
                $this.Load()
            }
            
            # Sauvegarder le fichier
            $bytes = [System.Convert]::FromBase64String($this.ContentBytes)
            [System.IO.File]::WriteAllBytes($Path, $bytes)
            
            Write-Verbose "Pièce jointe sauvegardée: $Path"
        }
        catch {
            Write-Error "Erreur lors de la sauvegarde de la pièce jointe: $_"
        }
    }
    
    $obj.PSObject.TypeNames.Insert(0, 'EwsCompat.Attachment')
    
    return $obj
}

<#
.SYNOPSIS
    Sauvegarde toutes les pièces jointes d'un message
    
.PARAMETER Message
    Objet message compatible EWS
    
.PARAMETER DestinationPath
    Chemin de destination pour les pièces jointes
    
.EXAMPLE
    Save-EwsCompatAttachments -Message $message -DestinationPath "C:\Temp\"
#>
function Save-EwsCompatAttachments {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $Message,
        
        [Parameter(Mandatory = $true)]
        [string]$DestinationPath
    )
    
    try {
        # Créer le répertoire si nécessaire
        if (-not (Test-Path $DestinationPath)) {
            New-Item -ItemType Directory -Path $DestinationPath -Force | Out-Null
        }
        
        $savedFiles = @()
        
        foreach ($attachment in $Message.Attachments) {
            $filePath = Join-Path $DestinationPath $attachment.Name
            
            # Charger et sauvegarder
            $attachment.Load()
            $attachment.SaveToFile($filePath)
            
            $savedFiles += $filePath
        }
        
        return $savedFiles
    }
    catch {
        Write-Error "Erreur lors de la sauvegarde des pièces jointes: $_"
        return @()
    }
}

#endregion

#region Envoi de Messages

<#
.SYNOPSIS
    Envoie un email via Graph (équivalent à EmailMessage.SendAndSaveCopy)
    
.DESCRIPTION
    Simule la création et l'envoi d'un EmailMessage EWS via Microsoft Graph
    
.PARAMETER Subject
    Sujet de l'email
    
.PARAMETER Body
    Corps de l'email (texte ou HTML)
    
.PARAMETER BodyType
    Type de corps: "Text" ou "HTML" (défaut: "HTML")
    
.PARAMETER ToRecipients
    Tableau d'adresses email des destinataires
    
.PARAMETER CcRecipients
    Tableau d'adresses email en copie (optionnel)
    
.PARAMETER Attachments
    Tableau de chemins de fichiers à attacher (optionnel)
    
.PARAMETER SaveToSentItems
    Si true, sauvegarde dans les éléments envoyés (défaut: true)
    
.EXAMPLE
    Send-EwsCompatMessage -Subject "Test" -Body "Hello" -ToRecipients @("user@domain.com")
    
.EXAMPLE
    Send-EwsCompatMessage -Subject "Report" -Body "<h1>Report</h1>" -BodyType "HTML" `
                          -ToRecipients @("user1@domain.com", "user2@domain.com") `
                          -CcRecipients @("cc@domain.com") `
                          -Attachments @("C:\report.pdf")
#>
function Send-EwsCompatMessage {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Subject,
        
        [Parameter(Mandatory = $true)]
        [string]$Body,
        
        [Parameter(Mandatory = $false)]
        [ValidateSet("Text", "HTML")]
        [string]$BodyType = "HTML",
        
        [Parameter(Mandatory = $true)]
        [string[]]$ToRecipients,
        
        [Parameter(Mandatory = $false)]
        [string[]]$CcRecipients = @(),
        
        [Parameter(Mandatory = $false)]
        [string[]]$Attachments = @(),
        
        [Parameter(Mandatory = $false)]
        [bool]$SaveToSentItems = $true
    )
    
    if (-not $script:EwsCompat_CurrentUser) {
        throw "Utilisateur non initialisé. Appelez Initialize-EwsCompatConnection d'abord."
    }
    
    try {
        Write-Verbose "Préparation de l'envoi d'email via Graph"
        Write-Verbose "De: $script:EwsCompat_CurrentUser"
        Write-Verbose "À: $($ToRecipients -join ', ')"
        Write-Verbose "Sujet: $Subject"
        
        # Préparer les destinataires au format Graph
        $toRecipientsGraph = @()
        foreach ($recipient in $ToRecipients) {
            $toRecipientsGraph += @{
                EmailAddress = @{
                    Address = $recipient
                }
            }
        }
        
        # Préparer les destinataires en copie
        $ccRecipientsGraph = @()
        foreach ($recipient in $CcRecipients) {
            $ccRecipientsGraph += @{
                EmailAddress = @{
                    Address = $recipient
                }
            }
        }
        
        # Construire le message
        $message = @{
            Subject = $Subject
            Body = @{
                ContentType = $BodyType
                Content = $Body
            }
            ToRecipients = $toRecipientsGraph
        }
        
        # Ajouter CC si présent
        if ($ccRecipientsGraph.Count -gt 0) {
            $message.CcRecipients = $ccRecipientsGraph
        }
        
        # Gérer les pièces jointes si présentes
        if ($Attachments.Count -gt 0) {
            Write-Verbose "Traitement de $($Attachments.Count) pièce(s) jointe(s)"
            $message.Attachments = @()
            
            foreach ($attachmentPath in $Attachments) {
                if (Test-Path $attachmentPath) {
                    $fileName = Split-Path $attachmentPath -Leaf
                    $fileBytes = [System.IO.File]::ReadAllBytes($attachmentPath)
                    $base64 = [System.Convert]::ToBase64String($fileBytes)
                    
                    $message.Attachments += @{
                        "@odata.type" = "#microsoft.graph.fileAttachment"
                        Name = $fileName
                        ContentBytes = $base64
                    }
                    
                    Write-Verbose "Pièce jointe ajoutée: $fileName"
                }
                else {
                    Write-Warning "Fichier non trouvé: $attachmentPath"
                }
            }
        }
        
        # Envoyer le message
        $params = @{
            UserId = $script:EwsCompat_CurrentUser
            Message = $message
            SaveToSentItems = $SaveToSentItems
        }
        
        Send-MgUserMail @params
        
        Write-Verbose "Email envoyé avec succès via Graph"
        
        return @{
            Success = $true
            Message = "Email envoyé avec succès"
        }
    }
    catch {
        Write-Error "Erreur lors de l'envoi de l'email: $_"
        Write-Verbose "Détails: $($_.Exception.Message)"
        
        return @{
            Success = $false
            Error = $_.Exception.Message
        }
    }
}

#endregion

#region Fonctions Utilitaires

<#
.SYNOPSIS
    Obtient le nombre de messages dans un dossier
    
.PARAMETER FolderId
    ID du dossier ou objet dossier compatible EWS
    
.EXAMPLE
    $count = Get-EwsCompatFolderMessageCount -FolderId $folder.Id
#>
function Get-EwsCompatFolderMessageCount {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $FolderId
    )
    
    try {
        # Extraire l'ID si c'est un objet
        if ($FolderId -is [PSCustomObject] -and $FolderId.Id) {
            return $FolderId.TotalCount
        }
        
        # Sinon récupérer le dossier
        $folder = Get-MgUserMailFolder -UserId $script:EwsCompat_CurrentUser -MailFolderId $FolderId
        return $folder.TotalItemCount
    }
    catch {
        Write-Error "Erreur lors de la récupération du nombre de messages: $_"
        return 0
    }
}

#endregion

# Export des fonctions
Export-ModuleMember -Function @(
    'Initialize-EwsCompatConnection',
    'Get-EwsCompatFolder',
    'Get-EwsCompatMessages',
    'Save-EwsCompatAttachments',
    'Get-EwsCompatFolderMessageCount'
)