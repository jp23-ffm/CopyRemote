#!/usr/bin/env python
“””
Outil CLI pour monitorer le cluster en temps réel.

Usage:
python watch_cluster.py              # Watch toutes les 5 secondes
python watch_cluster.py –interval 2 # Watch toutes les 2 secondes
python watch_cluster.py –once       # Une seule fois
“””

import argparse
import requests
import time
import sys
from datetime import datetime

# ANSI colors

class C:
HEADER = ‘\033[95m’
BLUE = ‘\033[94m’
CYAN = ‘\033[96m’
GREEN = ‘\033[92m’
YELLOW = ‘\033[93m’
RED = ‘\033[91m’
END = ‘\033[0m’
BOLD = ‘\033[1m’
UNDERLINE = ‘\033[4m’

def clear_screen():
“”“Clear terminal screen”””
print(’\033[2J\033[H’, end=’’)

def status_color(status):
“”“Return color based on status”””
colors = {
‘OK’: C.GREEN,
‘Warning’: C.YELLOW,
‘Error’: C.RED,
‘Degraded’: C.YELLOW,
‘Critical’: C.RED,
‘Stale’: C.RED,
‘Unknown’: C.CYAN
}
return colors.get(status, C.END)

def format_staleness(seconds):
“”“Format staleness in human readable format”””
if seconds is None:
return “N/A”

```
if seconds < 60:
    return f"{seconds:.1f}s"
elif seconds < 3600:
    return f"{seconds/60:.1f}min"
else:
    return f"{seconds/3600:.1f}h"
```

def print_cluster_status(data):
“”“Print formatted cluster status”””

```
# Header
print(f"\n{C.BOLD}{C.BLUE}{'='*80}{C.END}")
print(f"{C.BOLD}{C.BLUE}  CLUSTER STATUS - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}{C.END}")
print(f"{C.BOLD}{C.BLUE}{'='*80}{C.END}\n")

# Cluster overview
cluster_status = data.get('cluster_status', 'Unknown')
color = status_color(cluster_status)
print(f"  {C.BOLD}Cluster Status:{C.END} {color}{cluster_status}{C.END}")

summary = data.get('summary', {})
print(f"  {C.BOLD}Total Nodes:{C.END}    {summary.get('total_nodes', 0)}")
print(f"  {C.BOLD}Healthy:{C.END}        {C.GREEN}{summary.get('healthy_nodes', 0)}{C.END}")

if summary.get('warning_nodes', 0) > 0:
    print(f"  {C.BOLD}Warning:{C.END}        {C.YELLOW}{summary['warning_nodes']}{C.END}")
if summary.get('error_nodes', 0) > 0:
    print(f"  {C.BOLD}Error:{C.END}          {C.RED}{summary['error_nodes']}{C.END}")
if summary.get('stale_nodes', 0) > 0:
    print(f"  {C.BOLD}Stale:{C.END}          {C.RED}{summary['stale_nodes']}{C.END}")

# Issues
if 'issues' in data:
    print(f"\n  {C.BOLD}{C.RED}Issues:{C.END}")
    for issue in data['issues']:
        print(f"    • {issue['message']}: {', '.join(issue['affected_nodes'])}")

# Nodes details
print(f"\n{C.BOLD}Nodes:{C.END}")
print(f"{'-'*80}")

nodes = data.get('nodes', [])
if not nodes:
    print(f"  {C.YELLOW}No nodes found{C.END}")
    return

# Table header
print(f"{'Node Name':<20} {'Status':<12} {'Staleness':<12} {'Checks':<20} {'Hostname':<20}")
print(f"{'-'*80}")

# Nodes
for node in nodes:
    name = node.get('node_name', 'Unknown')[:19]
    status = node.get('status', 'Unknown')
    staleness = format_staleness(node.get('staleness_seconds'))
    
    checks = node.get('checks_summary', {})
    checks_str = f"{checks.get('ok', 0)}✓ {checks.get('warning', 0)}⚠ {checks.get('error', 0)}✗"
    
    hostname = node.get('hostname', 'N/A')[:19]
    
    color = status_color(status)
    stale_marker = " ⚠" if node.get('is_stale') else ""
    
    print(f"{name:<20} {color}{status:<10}{C.END}{stale_marker} {staleness:<12} {checks_str:<20} {hostname:<20}")

print(f"{'-'*80}\n")
```

def fetch_cluster_status(url):
“”“Fetch cluster status from API”””
try:
response = requests.get(url, timeout=5)
if response.status_code in [200, 503]:
return response.json(), None
else:
return None, f”HTTP {response.status_code}”
except requests.exceptions.ConnectionError:
return None, “Connection refused - Is the server running?”
except requests.exceptions.Timeout:
return None, “Request timeout”
except Exception as e:
return None, str(e)

def main():
parser = argparse.ArgumentParser(description=‘Monitor cluster health in real-time’)
parser.add_argument(’–url’, default=‘http://localhost:8000/api/status/cluster’,
help=‘API endpoint URL (default: http://localhost:8000/api/status/cluster)’)
parser.add_argument(’–interval’, type=int, default=5,
help=‘Refresh interval in seconds (default: 5)’)
parser.add_argument(’–once’, action=‘store_true’,
help=‘Run once and exit’)

```
args = parser.parse_args()

try:
    while True:
        if not args.once:
            clear_screen()
        
        data, error = fetch_cluster_status(args.url)
        
        if error:
            print(f"\n{C.RED}Error: {error}{C.END}")
            if args.once:
                sys.exit(1)
        else:
            print_cluster_status(data)
        
        if args.once:
            sys.exit(0)
        
        print(f"{C.CYAN}Refreshing in {args.interval}s... (Ctrl+C to exit){C.END}")
        time.sleep(args.interval)
        
except KeyboardInterrupt:
    print(f"\n{C.CYAN}Bye!{C.END}\n")
    sys.exit(0)
```

if **name** == ‘**main**’:
main()
